<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>index2.html</title>
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
    <style>
   body {
    font-family: "Source Code Pro", monospace;
   }
   .clear {
    background-color: #fff;
    color: #500;
   }
   .white {
    background-color: #fff;
    color: #050;
   }
   .comment {
    background-color: #fef;
    color: #0c0;
   }
   .directive {
    background-color: #fff;
    color: #a00;
   }
   .string {
    background-color: #fff;
    color: #0a0;
   }
   .charline {
    background-color: #fff;
    color: #00a;
   }
   .operator {
    background-color: #fff;
    color: #550;
   }
   .delim {
    background-color: #fff;
    color: #505;
   }
   .reserved {
    background-color: #fff;
    color: #055;
   }
   .num {
    background-color: #fff;
    color: #aa0;
   }
   .error {
    background-color: #fff;
    color: #a0a;
   }
  </style>
</head>
<body>
<p><span class = "comment">//Stoian Arsen, group K-10</span><br>
<span class = "clear">
</span><span class = "comment">//watch "lexer.h" & "testLexer.h" for declaration documentation</span><br>
<span class = "clear">
#include "lexer.h"</span><br>
<span class = "clear">
using std::string;</span><br>
<span class = "clear">
const string Lexer::delim = "#<%";</span><br>
<span class = "clear">
const string white_line = "\011\012\013\014\015\040";</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
string clearWhites(const string &s);</span><br>
<span class = "clear">
</span><span class = "comment">//clear white chars from the start and end of line</span><br>
<span class = "clear">
</span><span class = "comment">//middle whites do not changes</span><br>
<span class = "clear">
</span><span class = "comment">//can throw exceptions standard for std::string(bad_alloc)</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
LineType Lexer::load(const string& source){</span><br>
<span class = "clear">
    s = source;</span><br>
<span class = "clear">
    pos = 0;</span><br>
<span class = "clear">
    eof_ = false;</span><br>
<span class = "clear">
    if(s.empty()){</span><br>
<span class = "clear">
        type = LineType::Empty;</span><br>
<span class = "clear">
        pos = string::npos;}</span><br>
<span class = "clear">
    else{</span><br>
<span class = "clear">
        pos = 0;</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
        size_t i = s.find_first_of(delim, pos);</span><span class = "comment">//there possible that i == npos</span><br>
<span class = "clear">
        string tmp = clearWhites(s.substr(pos, i - pos));</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
        if(tmp == "")</span><br>
<span class = "clear">
            type = LineType::Empty;</span><br>
<span class = "clear">
        else{</span><br>
<span class = "clear">
            if(tmp == "footer")</span><br>
<span class = "clear">
                type = LineType::Footer;</span><br>
<span class = "clear">
            else{</span><br>
<span class = "clear">
                if(tmp == "header")</span><br>
<span class = "clear">
                    type = LineType::Header;</span><br>
<span class = "clear">
                else type = LineType::Line;</span><br>
<span class = "clear">
            }</span><br>
<span class = "clear">
        }</span><br>
<span class = "clear">
        if(type == LineType::Footer || type == LineType::Header){</span><br>
<span class = "clear">
        if(i == s.size() || i == string::npos){</span><br>
<span class = "clear">
            s = "";</span><br>
<span class = "clear">
            eof_ = true;</span><br>
<span class = "clear">
        }</span><br>
<span class = "clear">
        else</span><br>
<span class = "clear">
            pos = i + 1;</span><br>
<span class = "clear">
        }</span><br>
<span class = "clear">
    }</span><br>
<span class = "clear">
    return type;</span><br>
<span class = "clear">
}</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
bool Lexer::next(string &res){</span><br>
<span class = "clear">
    if(eof_)</span><br>
<span class = "clear">
        return false;</span><br>
<span class = "clear">
    if(s.empty()){</span><br>
<span class = "clear">
        res = "";</span><br>
<span class = "clear">
    eof_ = true;</span><br>
<span class = "clear">
        return true;}</span><br>
<span class = "clear">
    size_t i = s.find_first_of(delim, pos);</span><br>
<span class = "clear">
    res = clearWhites(s.substr(pos, i - pos));</span><br>
<span class = "clear">
    if(i != string::npos)</span><br>
<span class = "clear">
    {</span><br>
<span class = "clear">
        ++i;</span><br>
<span class = "clear">
        pos = i;</span><br>
<span class = "clear">
        return true;</span><br>
<span class = "clear">
    }</span><br>
<span class = "clear">
    else</span><br>
<span class = "clear">
        eof_ = true;</span><br>
<span class = "clear">
    return true;</span><br>
<span class = "clear">
}</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
bool Lexer::eof()const noexcept{ return eof_; }</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
string clearWhites(const string &s){</span><br>
<span class = "clear">
    size_t first = s.find_first_not_of(white_line);</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
    if(first == string::npos) return "";</span><br>
<span class = "clear">
    size_t last = s.find_last_not_of(white_line, s.size() );</span><br>
<span class = "clear">
    return s.substr(first, last - first + 1);</span><br>
<span class = "clear">
}</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
</span><br>
<span class = "clear">
</span><br>
</p></body>
</html>